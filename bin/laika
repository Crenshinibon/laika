#!/usr/bin/env node

var Phantom = require('node-phantom');
var colors = require('colors');
var Injector = require('../lib/injector');
var App = require('../lib/app');
var AppPool = require('../lib/app_pool');
var ServerConnector = require('../lib/connectors/server.js');
var ClientConnector = require('../lib/connectors/client.js');
var helpers = require('../lib/helpers');
var qbox = require('qbox');

// var injectPort = helpers.getRandomPort();
// var injector = new Injector({injectPort: injectPort});
var injectPort = helpers.getRandomPort();
var notificationPort = helpers.getRandomPort();
var injector = new Injector({
  injectPort: injectPort,
  notificationPort: notificationPort
});
var deps = qbox.create(2);
var phantom;
var appPool;

//add --recursive tests argvs
process.argv.push('--recursive');
process.argv.push('tests');

console.info('\n  injecting laika...'.blue.bold);
injector.inject();
App.touch(deps.tick.bind(deps));

console.info('  loading phantomjs...'.blue.bold);
Phantom.create(function(err, ph) {
  if(err) {
    console.log('  please install phantomjs to countinue'.red.bold);
    throw err; 
  } else {
    phantom = ph;
    deps.tick();
  }
});

deps.ready(function() {
  console.info('  loading initial app pool...'.blue.bold);
  appPool = new AppPool({size: 4, appDir: './'});
  appPool.on('ready', onAppPoolReady);
});

function onAppPoolReady() {
  require('mocha/bin/_mocha');
}


laika = function(callback) {
  return function (done) {    
    var completed = false;
    var args = [];

    //create new server with different db and port
    var app = appPool.get();
    var appPort = app.port
    var mongoDbname = app.dbname;
    var appUrl = "http://localhost:" + appPort;

    app.ready(function(injectPort) {
      if(callback.length == 0) {
        args = [];
      } else if(callback.length == 1) {
        args = [cleanAndDone];
      } else if(callback.length == 2) {
        args = [cleanAndDone, new ServerConnector(injectPort)];
      } else {
        args = [cleanAndDone, new ServerConnector(injectPort)];
        var noClients = callback.length - 2;
        for(var lc = 0; lc<noClients; lc++) {
          args.push(new ClientConnector(phantom, appUrl));
        }
      }

      callback.apply(null, args);
      if(args.length == 0) {
        completeTest();
      }
    });

    function cleanAndDone() {
      if(!completed) {
        args.slice(1).forEach(function(connector) {
          connector.close();
        });
        completeTest();      
      }
    }

    function completeTest() {
      app.close(function() {
        completed = true;
        done();
      });
    }
  }
}

process.on('exit', function() {
  console.log('  cleaning up injected code\n'.blue.bold);
  injector.clean();
  appPool.close();
  phantom._phantom.kill();
});
