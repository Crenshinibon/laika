#!/usr/bin/env node

var Phantom = require('node-phantom');
var colors = require('colors');
var Injector = require('../lib/injector');
var App = require('../lib/app');
var ServerConnector = require('../lib/connectors/server.js');
var ClientConnector = require('../lib/connectors/client.js');
var helpers = require('../lib/helpers');
var qbox = require('qbox');

// var injectPort = helpers.getRandomPort();
// var injector = new Injector({injectPort: injectPort});
var injectPort = helpers.getRandomPort();
var notificationPort = helpers.getRandomPort();
var injector = new Injector({
  injectPort: injectPort,
  notificationPort: notificationPort
});
var deps = qbox.create(2);
var phantom;

//add --recursive tests argvs
process.argv.push('--recursive');
process.argv.push('tests');

deps.ready(function() {
  require('mocha/bin/_mocha');
});
// injector.on('ready', deps.tick.bind(qbox));
// injector.on('interrupted', function() {
//   console.log('  tests interrupted with app reload!\n  do not update the app while test is running.'.red.bold);
//   process.exit(1);
// });

console.info('\n  injecting laika...'.blue.bold);
injector.inject();
App.touch(deps.tick.bind(deps));

console.info('  loading phantomjs...'.blue.bold);
Phantom.create(function(err, ph) {
  if(err) {
    console.log('  please install phantomjs to countinue'.red.bold);
    throw err; 
  } else {
    phantom = ph;
    deps.tick();
    // require('mocha/bin/_mocha');
  }
});

laika = function(callback) {
  return function (done) {    
    var completed = false;
    var args = [];

    //create new server with different db and port
    var appPort = helpers.getRandomPort();
    var mongoDbname = helpers.randomId(10);
    var appUrl = "http://localhost:" + appPort;

    injector.resetStatus();
    var app = new App();
    app.start(mongoDbname, appPort);

    var d = Date.now();
    injector.once('ready', function() {
      console.log(Date.now() -d);
      if(callback.length == 0) {
        args = [];
      } else if(callback.length == 1) {
        args = [cleanAndDone];
      } else if(callback.length == 2) {
        args = [cleanAndDone, new ServerConnector(injectPort)];
      } else {
        args = [cleanAndDone, new ServerConnector(injectPort)];
        var noClients = callback.length - 2;
        for(var lc = 0; lc<noClients; lc++) {
          args.push(new ClientConnector(phantom, appUrl));
        }
      }

      callback.apply(null, args);
      if(args.length == 0) {
        completeTest();
      }
    });

    function cleanAndDone() {
      if(!completed) {
        args.slice(1).forEach(function(connector) {
          connector.close();
        });
        completeTest();      
      }
    }

    function completeTest() {
      app.close(function() {
        completed = true;
        done();
      });
    }
  }
}

process.on('exit', function() {
  console.log('  cleaning up injected code\n'.blue.bold);
  injector.clean();
  phantom._phantom.kill();
});
